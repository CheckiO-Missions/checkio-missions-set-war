<div class="story for_info_only">
...соперник сэра Рональда — Умберт, оказался весьма умелым воином. К тому же он был на добрых полтора десятка лет младше, что давало ему определённое преимущество. Но и сэр Рональд был весьма силён — на его стороне был опыт участия во множестве битв и в нескольких крупных войнах. Кроме того, в молодости он славился как лучший дуэлянт в этих краях.<br>
Убедившись, что силы равны, каждый из них принял единственно возможное решение — позвать подмогу. Умберт послал за подкреплением кучера на лошади, сэр Рональд использовал фамильный рог, звук которого не раз звучал в жарких битвах. Замок рыцаря находился достаточно близко, чтобы там услышали призыв к оружию. Где находились сообщники Умберта — было неизвестно, и это чертовски мешало продумать стратегию для грядущей битвы.<br>
К счастью, подкрепление для обоих сторон подоспело практически одновременно. Теперь это был больше, чем вопрос чести девушки — возникшую ситуацию уже поздно было решать миром. Одна из двух армий должна быть уничтожена.
<div>

<p>
В прошлой миссии — Warriors — вы научились устраивать дуэли между 2 отдельными воинами. Отличная работа! Но давайте перейдём к чему-то более эпичному — к армиям! В этой миссии ваша задача — добавить к уже существующим классам и функциям новые.Одним из новых классов должен стать класс - <strong>Army</strong>, который будет обладать методом <strong>add_units()</strong>, позволяющим добавлять выбранное количество воинов в армию. Первый добавленный юнит будет первым, кто вступит в бой, второй будет вторым, и так далее. Также нужно создать  класс <strong>Battle()</strong> с функцией <strong>fight()</strong>, которая будет устраивать сражения и определять сильнейшую армию.<br>
Сражения между армиями происходят по следующему принципу:<br>
• сперва проводится дуэль между первым воином первой армии и первым воином второй<br>
• как только один из них погибает — в дуэль вступает следующий воин из той армии, которая потеряла бойца, а выживший воин со своим текущим здоровьем продолжает сражаться<br>
• так продолжается до тех пор, пока все воины одной из армий не умрут. В этом случае функция battle() возвращает <strong>True</strong>, если первая армия выиграла или <strong>False</strong>, если вторая оказалась сильнее.
</p> 

<p>
Обратите внимание, что первая армия имеет преимущество, чтобы начать каждый бой!
</p>

<p class="for_info_only" style="text-align: center;">
    <img  title="battle" src="{{MEDIA}}battle.png" alt="example" style="max-height: 1000px"/>
</p>

<div class="for_info_only">
<p>
<strong>Пример</strong>:
<pre class="brush: python">
chuck = Warrior()
bruce = Warrior()
carl = Knight()
dave = Warrior()
mark = Warrior()

fight(chuck, bruce) == True
fight(dave, carl) == False
chuck.is_alive == True
bruce.is_alive == False
carl.is_alive == True
dave.is_alive == False
fight(carl, mark) == False
carl.is_alive == False

my_army = Army()
my_army.add_units(Knight, 3)
    
enemy_army = Army()
enemy_army.add_units(Warrior, 3)

army_3 = Army()
army_3.add_units(Warrior, 20)
army_3.add_units(Knight, 5)
    
army_4 = Army()
army_4.add_units(Warrior, 30)

battle = Battle()

battle.fight(my_army, enemy_army) == True
battle.fight(army_3, army_4) == False
</pre>
</p>
</div>

<p>
    <strong>Входные данные: </strong>воины и армии.
</p>

<p>
    <strong>Выходные данные: </strong>результат битвы (True или False).
</p>


<p class="for_info_only">
    <strong>Как это используется: </strong>
    Для разработки компьютерных игр.
</p>

<p>
    <strong>Предусловие:</strong>
    <ul>
        <li>2 типа солдат</li>
        <li>Во всех битвах каждая из участвующих армий очевидно не является изначально пустой.</li>
    </ul>
</p>
